defmodule ModuleStore do
  @moduledoc """
  Use a compiled module as a high-performance key-value store. Suitable for low-write, high-read data like global config.

  Because every mutation triggers a module recompilation, which requires using a global lock (per node) for mutations to prevent concurrent compilations causing a crash, write performance is awful (by design) and mutations should be kept to a minimum. You can expect write performance to be in the range of 5-25 ops/s. In return, read perfomance sits around 50 million ops/s.

  ## Examples / doctests

      # getter
      iex> ModuleStore.new(MyApp.Store, hello: "world!")
      iex> MyApp.Store.get(:hello)
      "world!"
      iex> MyApp.Store.get(:bye)
      nil
      iex> MyApp.Store.get(:bye, :default)
      :default

      # getter!
      iex> ModuleStore.new(MyApp.Store, hello: "world!")
      iex> MyApp.Store.get(:hello)
      "world!"
      iex> MyApp.Store.get!(:bye)
      ** (RuntimeError) key not found

      # put/get many values
      iex> ModuleStore.new(MyApp.Store, hello: "world!")
      iex> MyApp.Store.put_all(a: 0, b: 1)
      iex> MyApp.Store.get_all()
      %{a: 0, b: 1, hello: "world!"}

      # delete a value
      iex> ModuleStore.new(MyApp.Store, hello: "world!", a: 0)
      iex> MyApp.Store.delete(:a)
      iex> MyApp.Store.get_all()
      %{hello: "world!"}

  To prevent compiler warnings saying that your store does not exist, call `new/1` somewhere at compile time, for example in a separate .ex file like so:

  ```elixir
  # lib/my_app/store.ex
  ModuleStore.new(MyApp.Store)
  ```
  """

  @typedoc """
  Key-value pairs in the form of a map or keyword list.
  """
  @type pairs() :: keyword() | map()

  @get_all_doc """
  Get the full contents of this store as a map.
  """

  @doc @get_all_doc
  @callback get_all() :: map()

  @get_bang_doc """
  Get the value of `key` or raise.
  """
  @doc @get_bang_doc
  @callback get!(key :: term) :: value :: term

  @get_doc """
  Get the value of `key` or the default value.
  """
  @doc @get_doc
  @callback get(key :: term, default :: term) :: term

  @put_doc """
  Store `value` under `key`.

  Overwrites existing data that has the same key.
  """
  @doc @put_doc
  @callback put(key :: term, value :: term) :: :ok

  @delete_doc """
  Delete `key` and its value.
  """
  @doc @delete_doc
  @callback delete(key :: term) :: :ok

  @put_all_doc """
  Store all key-value `pairs`.

  Overwrites existing data that has the same key.
  """
  @doc @put_all_doc
  @callback put_all(pairs :: pairs) :: :ok

  @doc """
  Create a new storage module with the provided data.
  """
  @spec new(module(), pairs()) :: :ok
  def new(module_name, pairs \\ []) do
    # lock to prevent concurrent-recompilation crashes
    lock_id = :crypto.strong_rand_bytes(16)
    :global.set_lock({module_name, lock_id}, [Node.self()])

    pairs = pairs |> Map.new() |> Macro.escape()

    Code.compiler_options(ignore_module_conflict: true)

    quote generated: true,
          bind_quoted: [
            pairs: pairs,
            module_name: module_name,
            module_doc: @moduledoc,
            get_all_doc: @get_all_doc,
            get_bang_doc: @get_bang_doc,
            get_doc: @get_doc,
            put_doc: @put_doc,
            delete_doc: @delete_doc,
            put_all_doc: @put_all_doc
          ],
          location: :keep do
      defmodule module_name do
        @moduledoc """
        Module-based key-value store generated by `ModuleStore`.

        #{module_doc}
        """
        @behaviour ModuleStore
        @pairs pairs

        @impl true
        @doc get_all_doc
        def get_all(), do: @pairs

        @impl true
        @doc get_bang_doc
        def get!(key)

        for {k, v} <- pairs do
          def get!(unquote(Macro.escape(k))), do: unquote(Macro.escape(v))
        end

        def get!(_), do: raise(RuntimeError, "key not found")

        @impl true
        @doc get_doc
        def get(key, default \\ nil)

        for {k, v} <- pairs do
          def get(unquote(Macro.escape(k)), _), do: unquote(Macro.escape(v))
        end

        def get(_, default), do: default

        @impl true
        @doc put_doc
        def put(key, value) do
          pairs = Map.put(@pairs, key, value)
          ModuleStore.new(__MODULE__, pairs)
        end

        @impl true
        @doc delete_doc
        def delete(key) do
          pairs = Map.delete(@pairs, key)
          ModuleStore.new(__MODULE__, pairs)
        end

        @impl true
        @doc put_all_doc
        def put_all(pairs) do
          pairs = Map.merge(@pairs, Map.new(pairs))
          ModuleStore.new(__MODULE__, pairs)
        end
      end
    end
    |> Code.compile_quoted()

    Code.compiler_options(ignore_module_conflict: false)
    :global.del_lock({module_name, lock_id}, [Node.self()])
    :ok
  end
end
